



--문제가 요구하는 것------------------------------------
symmetric pairs
order by asc of x
List the rows such that X1 ≤ Y1 (= X1 ≤ Y1이 되도록 행 나열)
즉, x값이 y값보다 작아야 함.
--------------------------------------------------------



--생각---------------------------------------------------
x1 = y2, x2 = y1 이라면 join을 할 수 있겠다.
binary tree 문제처럼.
그럼 y1 = x2 인 조건으로 join하면 되겠다. 
---------------------------------------------------------



--생각---------------------------------------------------
구한 값을 서브쿼리로 빼야 (x1 y1 x2 y2)의 형태가 아닌 sample output 값처럼 x1 y1의 형태로 나올 수 있겠다.
!!!! 아님 select를 *로 하지 말고 칼럼을 설정해주면 됨. 
---------------------------------------------------------


---------------------------------------------------------
select f1.x, f1.y
from Functions f1
inner join Functions f2 
on f1.Y = f2.X and f2.Y = f1.X
and f1.x <= f1.y
order by f1.x asc;
---------------------------------------------------------


틀림. 왜?

구글링.
-> X=Y 이지만 짝꿍이 없는 케이스가 포함되게 됩니다.
-> WHERE X=Y가 테이블에 두 번 존재하는지 확인해야 한다.

? 무슨 말인지 모르겠다.

❗ **pair** 찾는 거니까 X = Y 인 경우 같은 데이터가 하나 더 있어야 한다.
그래서 count > 1 이 필요하구나.


---------------------------------------------------------
select f1.x, f1.y
from Functions f1
    inner join Functions f2 
    on f1.Y = f2.X and f2.Y = f1.X
group by f1.x, f1.y
having count(f1.x) > 1 or f1.x <= f1.y
order by f1.x asc;
---------------------------------------------------------


틀림. 왜?


---------------------------------------------------------
f1.x <= f1.y
---------------------------------------------------------


≤ 에서 = 붙여서 틀림.
❗ ≤ 하면 or 조건이라서 페어가 없는 애들도 포함되는 구나. count(f1.x) > 1 조건이 무의미해지는 것.
그래서 x=y일 경우 중복되는 값이 있어서 pair가 되는지 여부를 알기 위해 count 조건을 넣고
x!=y일 경우 x<y보다 작아야 한다는 조건을 걸면 되는구나.



--정답---------------------------------------------------
select f1.x, f1.y
from Functions f1
    inner join Functions f2 
    on f1.Y = f2.X and f2.Y = f1.X
group by f1.x, f1.y
having count(f1.x) > 1 or f1.x < f1.y
order by f1.x;
---------------------------------------------------------




추가로 union을 쓸 수도 있다는데 그건 우선 안 배웠고 어려워서 잠정적 보류.


